# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import JavaScriptUnlexer


class JavaScriptUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(JavaScriptUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def program(self):
        current = self.create_node(UnparserRule(name='program'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.HashBangLine()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.sourceElements()

        current += self.unlexer.EOF()
        return current
    program.min_depth = 1

    @depthcontrol
    def sourceElement(self):
        current = self.create_node(UnparserRule(name='sourceElement'))
        current += self.statement()
        return current
    sourceElement.min_depth = 2

    @depthcontrol
    def statement(self):
        current = self.create_node(UnparserRule(name='statement'))
        choice = self.choice([0 if [1, 5, 3, 4, 2, 3, 5, 5, 4, 2, 2, 2, 2, 5, 3, 5, 5, 3, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_635', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_635', choice)] = self.unlexer.weights.get(('alt_635', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.block()
        elif choice == 1:
            current += self.variableStatement()
        elif choice == 2:
            current += self.importStatement()
        elif choice == 3:
            current += self.exportStatement()
        elif choice == 4:
            current += self.emptyStatement()
        elif choice == 5:
            current += self.classDeclaration()
        elif choice == 6:
            current += self.expressionStatement()
        elif choice == 7:
            current += self.ifStatement()
        elif choice == 8:
            current += self.iterationStatement()
        elif choice == 9:
            current += self.continueStatement()
        elif choice == 10:
            current += self.breakStatement()
        elif choice == 11:
            current += self.returnStatement()
        elif choice == 12:
            current += self.yieldStatement()
        elif choice == 13:
            current += self.withStatement()
        elif choice == 14:
            current += self.labelledStatement()
        elif choice == 15:
            current += self.switchStatement()
        elif choice == 16:
            current += self.throwStatement()
        elif choice == 17:
            current += self.tryStatement()
        elif choice == 18:
            current += self.debuggerStatement()
        elif choice == 19:
            current += self.functionDeclaration()
        return current
    statement.min_depth = 1

    @depthcontrol
    def block(self):
        current = self.create_node(UnparserRule(name='block'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        current += self.create_node(UnlexerRule(src='}'))
        return current
    block.min_depth = 0

    @depthcontrol
    def statementList(self):
        current = self.create_node(UnparserRule(name='statementList'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.statement()

        return current
    statementList.min_depth = 2

    @depthcontrol
    def importStatement(self):
        current = self.create_node(UnparserRule(name='importStatement'))
        current += self.unlexer.Import()
        current += self.importFromBlock()
        return current
    importStatement.min_depth = 2

    @depthcontrol
    def importFromBlock(self):
        current = self.create_node(UnparserRule(name='importFromBlock'))
        choice = self.choice([0 if [2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_659', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_659', choice)] = self.unlexer.weights.get(('alt_659', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 5:
                for _ in self.zero_or_one():
                    current += self.importDefault()

            choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_663', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_663', choice)] = self.unlexer.weights.get(('alt_663', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.importNamespace()
            elif choice == 1:
                current += self.moduleItems()
            current += self.importFrom()
            current += self.eos()
        elif choice == 1:
            current += self.unlexer.StringLiteral()
            current += self.eos()
        return current
    importFromBlock.min_depth = 1

    @depthcontrol
    def moduleItems(self):
        current = self.create_node(UnparserRule(name='moduleItems'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.aliasName()
                current += self.create_node(UnlexerRule(src=','))

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.aliasName()
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src=','))


        current += self.create_node(UnlexerRule(src='}'))
        return current
    moduleItems.min_depth = 0

    @depthcontrol
    def importDefault(self):
        current = self.create_node(UnparserRule(name='importDefault'))
        current += self.aliasName()
        current += self.create_node(UnlexerRule(src=','))
        return current
    importDefault.min_depth = 4

    @depthcontrol
    def importNamespace(self):
        current = self.create_node(UnparserRule(name='importNamespace'))
        choice = self.choice([0 if [0, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_674', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_674', choice)] = self.unlexer.weights.get(('alt_674', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='*'))
        elif choice == 1:
            current += self.identifierName()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.As()
                current += self.identifierName()

        return current
    importNamespace.min_depth = 0

    @depthcontrol
    def importFrom(self):
        current = self.create_node(UnparserRule(name='importFrom'))
        current += self.unlexer.From()
        current += self.unlexer.StringLiteral()
        return current
    importFrom.min_depth = 1

    @depthcontrol
    def aliasName(self):
        current = self.create_node(UnparserRule(name='aliasName'))
        current += self.identifierName()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.As()
                current += self.identifierName()

        return current
    aliasName.min_depth = 3

    @depthcontrol
    def exportStatement(self):
        current = self.create_node(UnparserRule(name='exportStatement'))
        choice = self.choice([0 if [3, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_680', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_680', choice)] = self.unlexer.weights.get(('alt_680', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.exportStatement_ExportDeclaration()
        elif choice == 1:
            current = self.exportStatement_ExportDefaultDeclaration()
        return current
    exportStatement.min_depth = 3

    @depthcontrol
    def exportStatement_ExportDeclaration(self):
        current = self.create_node(UnparserRule(name='exportStatement_ExportDeclaration'))
        current += self.unlexer.Export()
        choice = self.choice([0 if [2, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_683', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_683', choice)] = self.unlexer.weights.get(('alt_683', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.exportFromBlock()
        elif choice == 1:
            current += self.declaration()
        current += self.eos()
        return current
    exportStatement_ExportDeclaration.min_depth = 2

    @depthcontrol
    def exportStatement_ExportDefaultDeclaration(self):
        current = self.create_node(UnparserRule(name='exportStatement_ExportDefaultDeclaration'))
        current += self.unlexer.Export()
        current += self.unlexer.Default()
        current += self.singleExpression()
        current += self.eos()
        return current
    exportStatement_ExportDefaultDeclaration.min_depth = 3

    @depthcontrol
    def exportFromBlock(self):
        current = self.create_node(UnparserRule(name='exportFromBlock'))
        choice = self.choice([0 if [2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_686', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_686', choice)] = self.unlexer.weights.get(('alt_686', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.importNamespace()
            current += self.importFrom()
            current += self.eos()
        elif choice == 1:
            current += self.moduleItems()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.importFrom()

            current += self.eos()
        return current
    exportFromBlock.min_depth = 1

    @depthcontrol
    def declaration(self):
        current = self.create_node(UnparserRule(name='declaration'))
        choice = self.choice([0 if [5, 3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_690', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_690', choice)] = self.unlexer.weights.get(('alt_690', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.variableStatement()
        elif choice == 1:
            current += self.classDeclaration()
        elif choice == 2:
            current += self.functionDeclaration()
        return current
    declaration.min_depth = 3

    @depthcontrol
    def variableStatement(self):
        current = self.create_node(UnparserRule(name='variableStatement'))
        current += self.variableDeclarationList()
        current += self.eos()
        return current
    variableStatement.min_depth = 4

    @depthcontrol
    def variableDeclarationList(self):
        current = self.create_node(UnparserRule(name='variableDeclarationList'))
        current += self.varModifier()
        current += self.variableDeclaration()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.variableDeclaration()

        return current
    variableDeclarationList.min_depth = 3

    @depthcontrol
    def variableDeclaration(self):
        current = self.create_node(UnparserRule(name='variableDeclaration'))
        current += self.assignable()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='='))
                current += self.singleExpression()

        return current
    variableDeclaration.min_depth = 2

    @depthcontrol
    def emptyStatement(self):
        current = self.create_node(UnparserRule(name='emptyStatement'))
        current += self.unlexer.SemiColon()
        return current
    emptyStatement.min_depth = 1

    @depthcontrol
    def expressionStatement(self):
        current = self.create_node(UnparserRule(name='expressionStatement'))
        current += self.expressionSequence()
        current += self.eos()
        return current
    expressionStatement.min_depth = 4

    @depthcontrol
    def ifStatement(self):
        current = self.create_node(UnparserRule(name='ifStatement'))
        current += self.unlexer.If()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.Else()
                current += self.statement()

        return current
    ifStatement.min_depth = 4

    @depthcontrol
    def iterationStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement'))
        choice = self.choice([0 if [5, 5, 3, 5, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_701', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_701', choice)] = self.unlexer.weights.get(('alt_701', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.iterationStatement_DoStatement()
        elif choice == 1:
            current = self.iterationStatement_WhileStatement()
        elif choice == 2:
            current = self.iterationStatement_ForStatement()
        elif choice == 3:
            current = self.iterationStatement_ForInStatement()
        elif choice == 4:
            current = self.iterationStatement_ForOfStatement()
        return current
    iterationStatement.min_depth = 3

    @depthcontrol
    def iterationStatement_DoStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_DoStatement'))
        current += self.unlexer.Do()
        current += self.statement()
        current += self.unlexer.While()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.eos()
        return current
    iterationStatement_DoStatement.min_depth = 4

    @depthcontrol
    def iterationStatement_WhileStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_WhileStatement'))
        current += self.unlexer.While()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    iterationStatement_WhileStatement.min_depth = 4

    @depthcontrol
    def iterationStatement_ForStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_ForStatement'))
        current += self.unlexer.For()
        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                choice = self.choice([0 if [4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_713', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_713', choice)] = self.unlexer.weights.get(('alt_713', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.expressionSequence()
                elif choice == 1:
                    current += self.variableDeclarationList()

        current += self.create_node(UnlexerRule(src=';'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.create_node(UnlexerRule(src=';'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    iterationStatement_ForStatement.min_depth = 2

    @depthcontrol
    def iterationStatement_ForInStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_ForInStatement'))
        current += self.unlexer.For()
        current += self.create_node(UnlexerRule(src='('))
        choice = self.choice([0 if [3, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_722', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_722', choice)] = self.unlexer.weights.get(('alt_722', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.singleExpression()
        elif choice == 1:
            current += self.variableDeclarationList()
        current += self.unlexer.In()
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    iterationStatement_ForInStatement.min_depth = 4

    @depthcontrol
    def iterationStatement_ForOfStatement(self):
        current = self.create_node(UnparserRule(name='iterationStatement_ForOfStatement'))
        current += self.unlexer.For()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Await()

        current += self.create_node(UnlexerRule(src='('))
        choice = self.choice([0 if [3, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_728', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_728', choice)] = self.unlexer.weights.get(('alt_728', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.singleExpression()
        elif choice == 1:
            current += self.variableDeclarationList()
        current += self.identifier()
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    iterationStatement_ForOfStatement.min_depth = 4

    @depthcontrol
    def varModifier(self):
        current = self.create_node(UnparserRule(name='varModifier'))
        choice = self.choice([0 if [1, 2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_732', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_732', choice)] = self.unlexer.weights.get(('alt_732', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Var()
        elif choice == 1:
            current += self.let_()
        elif choice == 2:
            current += self.unlexer.Const()
        return current
    varModifier.min_depth = 1

    @depthcontrol
    def continueStatement(self):
        current = self.create_node(UnparserRule(name='continueStatement'))
        current += self.unlexer.Continue()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.identifier()

        current += self.eos()
        return current
    continueStatement.min_depth = 1

    @depthcontrol
    def breakStatement(self):
        current = self.create_node(UnparserRule(name='breakStatement'))
        current += self.unlexer.Break()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.identifier()

        current += self.eos()
        return current
    breakStatement.min_depth = 1

    @depthcontrol
    def returnStatement(self):
        current = self.create_node(UnparserRule(name='returnStatement'))
        current += self.unlexer.Return()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.eos()
        return current
    returnStatement.min_depth = 1

    @depthcontrol
    def yieldStatement(self):
        current = self.create_node(UnparserRule(name='yieldStatement'))
        current += self.unlexer.Yield()
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.expressionSequence()

        current += self.eos()
        return current
    yieldStatement.min_depth = 1

    @depthcontrol
    def withStatement(self):
        current = self.create_node(UnparserRule(name='withStatement'))
        current += self.unlexer.With()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.statement()
        return current
    withStatement.min_depth = 4

    @depthcontrol
    def switchStatement(self):
        current = self.create_node(UnparserRule(name='switchStatement'))
        current += self.unlexer.Switch()
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.caseBlock()
        return current
    switchStatement.min_depth = 4

    @depthcontrol
    def caseBlock(self):
        current = self.create_node(UnparserRule(name='caseBlock'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 6:
            for _ in self.zero_or_one():
                current += self.caseClauses()

        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.defaultClause()
                if self.unlexer.max_depth >= 6:
                    for _ in self.zero_or_one():
                        current += self.caseClauses()


        current += self.create_node(UnlexerRule(src='}'))
        return current
    caseBlock.min_depth = 0

    @depthcontrol
    def caseClauses(self):
        current = self.create_node(UnparserRule(name='caseClauses'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.caseClause()

        return current
    caseClauses.min_depth = 5

    @depthcontrol
    def caseClause(self):
        current = self.create_node(UnparserRule(name='caseClause'))
        current += self.unlexer.Case()
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=':'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        return current
    caseClause.min_depth = 4

    @depthcontrol
    def defaultClause(self):
        current = self.create_node(UnparserRule(name='defaultClause'))
        current += self.unlexer.Default()
        current += self.create_node(UnlexerRule(src=':'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.statementList()

        return current
    defaultClause.min_depth = 1

    @depthcontrol
    def labelledStatement(self):
        current = self.create_node(UnparserRule(name='labelledStatement'))
        current += self.identifier()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.statement()
        return current
    labelledStatement.min_depth = 2

    @depthcontrol
    def throwStatement(self):
        current = self.create_node(UnparserRule(name='throwStatement'))
        current += self.unlexer.Throw()
        current += self.expressionSequence()
        current += self.eos()
        return current
    throwStatement.min_depth = 4

    @depthcontrol
    def tryStatement(self):
        current = self.create_node(UnparserRule(name='tryStatement'))
        current += self.unlexer.Try()
        current += self.block()
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_754', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_754', choice)] = self.unlexer.weights.get(('alt_754', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.catchProduction()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.finallyProduction()

        elif choice == 1:
            current += self.finallyProduction()
        return current
    tryStatement.min_depth = 2

    @depthcontrol
    def catchProduction(self):
        current = self.create_node(UnparserRule(name='catchProduction'))
        current += self.unlexer.Catch()
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='('))
                if self.unlexer.max_depth >= 2:
                    for _ in self.zero_or_one():
                        current += self.assignable()

                current += self.create_node(UnlexerRule(src=')'))

        current += self.block()
        return current
    catchProduction.min_depth = 1

    @depthcontrol
    def finallyProduction(self):
        current = self.create_node(UnparserRule(name='finallyProduction'))
        current += self.unlexer.Finally()
        current += self.block()
        return current
    finallyProduction.min_depth = 1

    @depthcontrol
    def debuggerStatement(self):
        current = self.create_node(UnparserRule(name='debuggerStatement'))
        current += self.unlexer.Debugger()
        current += self.eos()
        return current
    debuggerStatement.min_depth = 1

    @depthcontrol
    def functionDeclaration(self):
        current = self.create_node(UnparserRule(name='functionDeclaration'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Async()

        current += self.unlexer.Function()
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='*'))

        current += self.identifier()
        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.formalParameterList()

        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    functionDeclaration.min_depth = 2

    @depthcontrol
    def classDeclaration(self):
        current = self.create_node(UnparserRule(name='classDeclaration'))
        current += self.unlexer.Class()
        current += self.identifier()
        current += self.classTail()
        return current
    classDeclaration.min_depth = 2

    @depthcontrol
    def classTail(self):
        current = self.create_node(UnparserRule(name='classTail'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.unlexer.Extends()
                current += self.singleExpression()

        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.classElement()

        current += self.create_node(UnlexerRule(src='}'))
        return current
    classTail.min_depth = 0

    @depthcontrol
    def classElement(self):
        current = self.create_node(UnparserRule(name='classElement'))
        choice = self.choice([0 if [2, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_774', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_774', choice)] = self.unlexer.weights.get(('alt_774', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    choice = self.choice([0 if [1, 2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_779', i), 1) for i, w in enumerate([1, 1, 1])])
                    self.unlexer.weights[('alt_779', choice)] = self.unlexer.weights.get(('alt_779', choice), 1) * self.unlexer.cooldown
                    if choice == 0:
                        current += self.unlexer.Static()
                    elif choice == 1:
                        current += self.identifier()
                    elif choice == 2:
                        current += self.unlexer.Async()

            choice = self.choice([0 if [3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_783', i), 1) for i, w in enumerate([1, 1])])
            self.unlexer.weights[('alt_783', choice)] = self.unlexer.weights.get(('alt_783', choice), 1) * self.unlexer.cooldown
            if choice == 0:
                current += self.methodDefinition()
            elif choice == 1:
                current += self.assignable()
                current += self.create_node(UnlexerRule(src='='))
                current += self.objectLiteral()
                current += self.create_node(UnlexerRule(src=';'))
        elif choice == 1:
            current += self.emptyStatement()
        elif choice == 2:
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src='#'))

            current += self.propertyName()
            current += self.create_node(UnlexerRule(src='='))
            current += self.singleExpression()
        return current
    classElement.min_depth = 2

    @depthcontrol
    def methodDefinition(self):
        current = self.create_node(UnparserRule(name='methodDefinition'))
        choice = self.choice([0 if [2, 3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_791', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_791', choice)] = self.unlexer.weights.get(('alt_791', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src='*'))

            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src='#'))

            current += self.propertyName()
            current += self.create_node(UnlexerRule(src='('))
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.formalParameterList()

            current += self.create_node(UnlexerRule(src=')'))
            current += self.create_node(UnlexerRule(src='{'))
            current += self.functionBody()
            current += self.create_node(UnlexerRule(src='}'))
        elif choice == 1:
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src='*'))

            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src='#'))

            current += self.getter()
            current += self.create_node(UnlexerRule(src='('))
            current += self.create_node(UnlexerRule(src=')'))
            current += self.create_node(UnlexerRule(src='{'))
            current += self.functionBody()
            current += self.create_node(UnlexerRule(src='}'))
        elif choice == 2:
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src='*'))

            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src='#'))

            current += self.setter()
            current += self.create_node(UnlexerRule(src='('))
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.formalParameterList()

            current += self.create_node(UnlexerRule(src=')'))
            current += self.create_node(UnlexerRule(src='{'))
            current += self.functionBody()
            current += self.create_node(UnlexerRule(src='}'))
        return current
    methodDefinition.min_depth = 2

    @depthcontrol
    def formalParameterList(self):
        current = self.create_node(UnparserRule(name='formalParameterList'))
        choice = self.choice([0 if [3, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_821', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_821', choice)] = self.unlexer.weights.get(('alt_821', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.formalParameterArg()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_more():
                    current += self.create_node(UnlexerRule(src=','))
                    current += self.formalParameterArg()

            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src=','))
                    current += self.lastFormalParameterArg()

        elif choice == 1:
            current += self.lastFormalParameterArg()
        return current
    formalParameterList.min_depth = 3

    @depthcontrol
    def formalParameterArg(self):
        current = self.create_node(UnparserRule(name='formalParameterArg'))
        current += self.assignable()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='='))
                current += self.singleExpression()

        return current
    formalParameterArg.min_depth = 2

    @depthcontrol
    def lastFormalParameterArg(self):
        current = self.create_node(UnparserRule(name='lastFormalParameterArg'))
        current += self.unlexer.Ellipsis()
        current += self.singleExpression()
        return current
    lastFormalParameterArg.min_depth = 3

    @depthcontrol
    def functionBody(self):
        current = self.create_node(UnparserRule(name='functionBody'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.sourceElements()

        return current
    functionBody.min_depth = 0

    @depthcontrol
    def sourceElements(self):
        current = self.create_node(UnparserRule(name='sourceElements'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.sourceElement()

        return current
    sourceElements.min_depth = 3

    @depthcontrol
    def arrayLiteral(self):
        current = self.create_node(UnparserRule(name='arrayLiteral'))
        current += self.create_node(UnlexerRule(src='['))
        current += self.elementList()
        current += self.create_node(UnlexerRule(src=']'))
        return current
    arrayLiteral.min_depth = 1

    @depthcontrol
    def elementList(self):
        current = self.create_node(UnparserRule(name='elementList'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.arrayElement()

        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 0:
                    for _ in self.one_or_more():
                        current += self.create_node(UnlexerRule(src=','))

                current += self.arrayElement()

        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))

        return current
    elementList.min_depth = 0

    @depthcontrol
    def arrayElement(self):
        current = self.create_node(UnparserRule(name='arrayElement'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Ellipsis()

        current += self.singleExpression()
        return current
    arrayElement.min_depth = 3

    @depthcontrol
    def propertyAssignment(self):
        current = self.create_node(UnparserRule(name='propertyAssignment'))
        choice = self.choice([0 if [4, 4, 3, 4, 4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_841', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_841', choice)] = self.unlexer.weights.get(('alt_841', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.propertyAssignment_PropertyExpressionAssignment()
        elif choice == 1:
            current = self.propertyAssignment_ComputedPropertyExpressionAssignment()
        elif choice == 2:
            current = self.propertyAssignment_FunctionProperty()
        elif choice == 3:
            current = self.propertyAssignment_PropertyGetter()
        elif choice == 4:
            current = self.propertyAssignment_PropertySetter()
        elif choice == 5:
            current = self.propertyAssignment_PropertyShorthand()
        return current
    propertyAssignment.min_depth = 3

    @depthcontrol
    def propertyAssignment_PropertyExpressionAssignment(self):
        current = self.create_node(UnparserRule(name='propertyAssignment_PropertyExpressionAssignment'))
        current += self.propertyName()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.singleExpression()
        return current
    propertyAssignment_PropertyExpressionAssignment.min_depth = 3

    @depthcontrol
    def propertyAssignment_ComputedPropertyExpressionAssignment(self):
        current = self.create_node(UnparserRule(name='propertyAssignment_ComputedPropertyExpressionAssignment'))
        current += self.create_node(UnlexerRule(src='['))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src=']'))
        current += self.create_node(UnlexerRule(src=':'))
        current += self.singleExpression()
        return current
    propertyAssignment_ComputedPropertyExpressionAssignment.min_depth = 3

    @depthcontrol
    def propertyAssignment_FunctionProperty(self):
        current = self.create_node(UnparserRule(name='propertyAssignment_FunctionProperty'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Async()

        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='*'))

        current += self.propertyName()
        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.formalParameterList()

        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    propertyAssignment_FunctionProperty.min_depth = 2

    @depthcontrol
    def propertyAssignment_PropertyGetter(self):
        current = self.create_node(UnparserRule(name='propertyAssignment_PropertyGetter'))
        current += self.getter()
        current += self.create_node(UnlexerRule(src='('))
        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    propertyAssignment_PropertyGetter.min_depth = 3

    @depthcontrol
    def propertyAssignment_PropertySetter(self):
        current = self.create_node(UnparserRule(name='propertyAssignment_PropertySetter'))
        current += self.setter()
        current += self.create_node(UnlexerRule(src='('))
        current += self.formalParameterArg()
        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    propertyAssignment_PropertySetter.min_depth = 3

    @depthcontrol
    def propertyAssignment_PropertyShorthand(self):
        current = self.create_node(UnparserRule(name='propertyAssignment_PropertyShorthand'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Ellipsis()

        current += self.singleExpression()
        return current
    propertyAssignment_PropertyShorthand.min_depth = 3

    @depthcontrol
    def propertyName(self):
        current = self.create_node(UnparserRule(name='propertyName'))
        choice = self.choice([0 if [3, 1, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_869', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_869', choice)] = self.unlexer.weights.get(('alt_869', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.identifierName()
        elif choice == 1:
            current += self.unlexer.StringLiteral()
        elif choice == 2:
            current += self.numericLiteral()
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='['))
            current += self.singleExpression()
            current += self.create_node(UnlexerRule(src=']'))
        return current
    propertyName.min_depth = 1

    @depthcontrol
    def arguments(self):
        current = self.create_node(UnparserRule(name='arguments'))
        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_one():
                current += self.argument()
                if self.unlexer.max_depth >= 3:
                    for _ in self.zero_or_more():
                        current += self.create_node(UnlexerRule(src=','))
                        current += self.argument()

                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src=','))


        current += self.create_node(UnlexerRule(src=')'))
        return current
    arguments.min_depth = 0

    @depthcontrol
    def argument(self):
        current = self.create_node(UnparserRule(name='argument'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Ellipsis()

        choice = self.choice([0 if [3, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_884', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_884', choice)] = self.unlexer.weights.get(('alt_884', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.singleExpression()
        elif choice == 1:
            current += self.identifier()
        return current
    argument.min_depth = 2

    @depthcontrol
    def expressionSequence(self):
        current = self.create_node(UnparserRule(name='expressionSequence'))
        current += self.singleExpression()
        if self.unlexer.max_depth >= 3:
            for _ in self.zero_or_more():
                current += self.create_node(UnlexerRule(src=','))
                current += self.singleExpression()

        return current
    expressionSequence.min_depth = 3

    @depthcontrol
    def singleExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression'))
        choice = self.choice([0 if [4, 2, 5, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 2, 3, 2, 3, 3, 2, 5][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_889', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_889', choice)] = self.unlexer.weights.get(('alt_889', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.singleExpression_FunctionExpression()
        elif choice == 1:
            current = self.singleExpression_ClassExpression()
        elif choice == 2:
            current = self.singleExpression_MemberIndexExpression()
        elif choice == 3:
            current = self.singleExpression_MemberDotExpression()
        elif choice == 4:
            current = self.singleExpression_ArgumentsExpression()
        elif choice == 5:
            current = self.singleExpression_NewExpression()
        elif choice == 6:
            current = self.singleExpression_MetaExpression()
        elif choice == 7:
            current = self.singleExpression_PostIncrementExpression()
        elif choice == 8:
            current = self.singleExpression_PostDecreaseExpression()
        elif choice == 9:
            current = self.singleExpression_DeleteExpression()
        elif choice == 10:
            current = self.singleExpression_VoidExpression()
        elif choice == 11:
            current = self.singleExpression_TypeofExpression()
        elif choice == 12:
            current = self.singleExpression_PreIncrementExpression()
        elif choice == 13:
            current = self.singleExpression_PreDecreaseExpression()
        elif choice == 14:
            current = self.singleExpression_UnaryPlusExpression()
        elif choice == 15:
            current = self.singleExpression_UnaryMinusExpression()
        elif choice == 16:
            current = self.singleExpression_BitNotExpression()
        elif choice == 17:
            current = self.singleExpression_NotExpression()
        elif choice == 18:
            current = self.singleExpression_AwaitExpression()
        elif choice == 19:
            current = self.singleExpression_PowerExpression()
        elif choice == 20:
            current = self.singleExpression_MultiplicativeExpression()
        elif choice == 21:
            current = self.singleExpression_AdditiveExpression()
        elif choice == 22:
            current = self.singleExpression_CoalesceExpression()
        elif choice == 23:
            current = self.singleExpression_BitShiftExpression()
        elif choice == 24:
            current = self.singleExpression_RelationalExpression()
        elif choice == 25:
            current = self.singleExpression_InstanceofExpression()
        elif choice == 26:
            current = self.singleExpression_InExpression()
        elif choice == 27:
            current = self.singleExpression_EqualityExpression()
        elif choice == 28:
            current = self.singleExpression_BitAndExpression()
        elif choice == 29:
            current = self.singleExpression_BitXOrExpression()
        elif choice == 30:
            current = self.singleExpression_BitOrExpression()
        elif choice == 31:
            current = self.singleExpression_LogicalAndExpression()
        elif choice == 32:
            current = self.singleExpression_LogicalOrExpression()
        elif choice == 33:
            current = self.singleExpression_TernaryExpression()
        elif choice == 34:
            current = self.singleExpression_AssignmentExpression()
        elif choice == 35:
            current = self.singleExpression_AssignmentOperatorExpression()
        elif choice == 36:
            current = self.singleExpression_ImportExpression()
        elif choice == 37:
            current = self.singleExpression_TemplateStringExpression()
        elif choice == 38:
            current = self.singleExpression_YieldExpression()
        elif choice == 39:
            current = self.singleExpression_ThisExpression()
        elif choice == 40:
            current = self.singleExpression_IdentifierExpression()
        elif choice == 41:
            current = self.singleExpression_SuperExpression()
        elif choice == 42:
            current = self.singleExpression_LiteralExpression()
        elif choice == 43:
            current = self.singleExpression_ArrayLiteralExpression()
        elif choice == 44:
            current = self.singleExpression_ObjectLiteralExpression()
        elif choice == 45:
            current = self.singleExpression_ParenthesizedExpression()
        return current
    singleExpression.min_depth = 2

    @depthcontrol
    def singleExpression_FunctionExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_FunctionExpression'))
        current += self.anoymousFunction()
        return current
    singleExpression_FunctionExpression.min_depth = 3

    @depthcontrol
    def singleExpression_ClassExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ClassExpression'))
        current += self.unlexer.Class()
        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.identifier()

        current += self.classTail()
        return current
    singleExpression_ClassExpression.min_depth = 1

    @depthcontrol
    def singleExpression_MemberIndexExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_MemberIndexExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='['))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=']'))
        return current
    singleExpression_MemberIndexExpression.min_depth = 4

    @depthcontrol
    def singleExpression_MemberDotExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_MemberDotExpression'))
        current += self.singleExpression()
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='?'))

        current += self.create_node(UnlexerRule(src='.'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='#'))

        current += self.identifierName()
        return current
    singleExpression_MemberDotExpression.min_depth = 3

    @depthcontrol
    def singleExpression_ArgumentsExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ArgumentsExpression'))
        current += self.singleExpression()
        current += self.arguments()
        return current
    singleExpression_ArgumentsExpression.min_depth = 3

    @depthcontrol
    def singleExpression_NewExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_NewExpression'))
        current += self.unlexer.New()
        current += self.singleExpression()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.arguments()

        return current
    singleExpression_NewExpression.min_depth = 3

    @depthcontrol
    def singleExpression_MetaExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_MetaExpression'))
        current += self.unlexer.New()
        current += self.create_node(UnlexerRule(src='.'))
        current += self.identifier()
        return current
    singleExpression_MetaExpression.min_depth = 2

    @depthcontrol
    def singleExpression_PostIncrementExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_PostIncrementExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='++'))
        return current
    singleExpression_PostIncrementExpression.min_depth = 3

    @depthcontrol
    def singleExpression_PostDecreaseExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_PostDecreaseExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='--'))
        return current
    singleExpression_PostDecreaseExpression.min_depth = 3

    @depthcontrol
    def singleExpression_DeleteExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_DeleteExpression'))
        current += self.unlexer.Delete()
        current += self.singleExpression()
        return current
    singleExpression_DeleteExpression.min_depth = 3

    @depthcontrol
    def singleExpression_VoidExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_VoidExpression'))
        current += self.unlexer.Void()
        current += self.singleExpression()
        return current
    singleExpression_VoidExpression.min_depth = 3

    @depthcontrol
    def singleExpression_TypeofExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_TypeofExpression'))
        current += self.unlexer.Typeof()
        current += self.singleExpression()
        return current
    singleExpression_TypeofExpression.min_depth = 3

    @depthcontrol
    def singleExpression_PreIncrementExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_PreIncrementExpression'))
        current += self.create_node(UnlexerRule(src='++'))
        current += self.singleExpression()
        return current
    singleExpression_PreIncrementExpression.min_depth = 3

    @depthcontrol
    def singleExpression_PreDecreaseExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_PreDecreaseExpression'))
        current += self.create_node(UnlexerRule(src='--'))
        current += self.singleExpression()
        return current
    singleExpression_PreDecreaseExpression.min_depth = 3

    @depthcontrol
    def singleExpression_UnaryPlusExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_UnaryPlusExpression'))
        current += self.create_node(UnlexerRule(src='+'))
        current += self.singleExpression()
        return current
    singleExpression_UnaryPlusExpression.min_depth = 3

    @depthcontrol
    def singleExpression_UnaryMinusExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_UnaryMinusExpression'))
        current += self.create_node(UnlexerRule(src='-'))
        current += self.singleExpression()
        return current
    singleExpression_UnaryMinusExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitNotExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitNotExpression'))
        current += self.create_node(UnlexerRule(src='~'))
        current += self.singleExpression()
        return current
    singleExpression_BitNotExpression.min_depth = 3

    @depthcontrol
    def singleExpression_NotExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_NotExpression'))
        current += self.create_node(UnlexerRule(src='!'))
        current += self.singleExpression()
        return current
    singleExpression_NotExpression.min_depth = 3

    @depthcontrol
    def singleExpression_AwaitExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_AwaitExpression'))
        current += self.unlexer.Await()
        current += self.singleExpression()
        return current
    singleExpression_AwaitExpression.min_depth = 3

    @depthcontrol
    def singleExpression_PowerExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_PowerExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='**'))
        current += self.singleExpression()
        return current
    singleExpression_PowerExpression.min_depth = 3

    @depthcontrol
    def singleExpression_MultiplicativeExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_MultiplicativeExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_955', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_955', choice)] = self.unlexer.weights.get(('alt_955', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='*'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='/'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='%'))
        current += self.singleExpression()
        return current
    singleExpression_MultiplicativeExpression.min_depth = 3

    @depthcontrol
    def singleExpression_AdditiveExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_AdditiveExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_962', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_962', choice)] = self.unlexer.weights.get(('alt_962', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='+'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='-'))
        current += self.singleExpression()
        return current
    singleExpression_AdditiveExpression.min_depth = 3

    @depthcontrol
    def singleExpression_CoalesceExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_CoalesceExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='??'))
        current += self.singleExpression()
        return current
    singleExpression_CoalesceExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitShiftExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitShiftExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_968', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_968', choice)] = self.unlexer.weights.get(('alt_968', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='<<'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='>>'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='>>>'))
        current += self.singleExpression()
        return current
    singleExpression_BitShiftExpression.min_depth = 3

    @depthcontrol
    def singleExpression_RelationalExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_RelationalExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_975', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_975', choice)] = self.unlexer.weights.get(('alt_975', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='<'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='>'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='<='))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='>='))
        current += self.singleExpression()
        return current
    singleExpression_RelationalExpression.min_depth = 3

    @depthcontrol
    def singleExpression_InstanceofExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_InstanceofExpression'))
        current += self.singleExpression()
        current += self.unlexer.Instanceof()
        current += self.singleExpression()
        return current
    singleExpression_InstanceofExpression.min_depth = 3

    @depthcontrol
    def singleExpression_InExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_InExpression'))
        current += self.singleExpression()
        current += self.unlexer.In()
        current += self.singleExpression()
        return current
    singleExpression_InExpression.min_depth = 3

    @depthcontrol
    def singleExpression_EqualityExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_EqualityExpression'))
        current += self.singleExpression()
        choice = self.choice([0 if [0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_984', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_984', choice)] = self.unlexer.weights.get(('alt_984', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='=='))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='!='))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='==='))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='!=='))
        current += self.singleExpression()
        return current
    singleExpression_EqualityExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitAndExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitAndExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='&'))
        current += self.singleExpression()
        return current
    singleExpression_BitAndExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitXOrExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitXOrExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='^'))
        current += self.singleExpression()
        return current
    singleExpression_BitXOrExpression.min_depth = 3

    @depthcontrol
    def singleExpression_BitOrExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_BitOrExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='|'))
        current += self.singleExpression()
        return current
    singleExpression_BitOrExpression.min_depth = 3

    @depthcontrol
    def singleExpression_LogicalAndExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_LogicalAndExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='&&'))
        current += self.singleExpression()
        return current
    singleExpression_LogicalAndExpression.min_depth = 3

    @depthcontrol
    def singleExpression_LogicalOrExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_LogicalOrExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='||'))
        current += self.singleExpression()
        return current
    singleExpression_LogicalOrExpression.min_depth = 3

    @depthcontrol
    def singleExpression_TernaryExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_TernaryExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='?'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.singleExpression()
        return current
    singleExpression_TernaryExpression.min_depth = 3

    @depthcontrol
    def singleExpression_AssignmentExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_AssignmentExpression'))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src='='))
        current += self.singleExpression()
        return current
    singleExpression_AssignmentExpression.min_depth = 3

    @depthcontrol
    def singleExpression_AssignmentOperatorExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_AssignmentOperatorExpression'))
        current += self.singleExpression()
        current += self.assignmentOperator()
        current += self.singleExpression()
        return current
    singleExpression_AssignmentOperatorExpression.min_depth = 3

    @depthcontrol
    def singleExpression_ImportExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ImportExpression'))
        current += self.unlexer.Import()
        current += self.create_node(UnlexerRule(src='('))
        current += self.singleExpression()
        current += self.create_node(UnlexerRule(src=')'))
        return current
    singleExpression_ImportExpression.min_depth = 3

    @depthcontrol
    def singleExpression_TemplateStringExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_TemplateStringExpression'))
        current += self.singleExpression()
        current += self.unlexer.TemplateStringLiteral()
        return current
    singleExpression_TemplateStringExpression.min_depth = 3

    @depthcontrol
    def singleExpression_YieldExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_YieldExpression'))
        current += self.yieldStatement()
        return current
    singleExpression_YieldExpression.min_depth = 2

    @depthcontrol
    def singleExpression_ThisExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ThisExpression'))
        current += self.unlexer.This()
        return current
    singleExpression_ThisExpression.min_depth = 1

    @depthcontrol
    def singleExpression_IdentifierExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_IdentifierExpression'))
        current += self.identifier()
        return current
    singleExpression_IdentifierExpression.min_depth = 2

    @depthcontrol
    def singleExpression_SuperExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_SuperExpression'))
        current += self.unlexer.Super()
        return current
    singleExpression_SuperExpression.min_depth = 1

    @depthcontrol
    def singleExpression_LiteralExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_LiteralExpression'))
        current += self.literal()
        return current
    singleExpression_LiteralExpression.min_depth = 2

    @depthcontrol
    def singleExpression_ArrayLiteralExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ArrayLiteralExpression'))
        current += self.arrayLiteral()
        return current
    singleExpression_ArrayLiteralExpression.min_depth = 2

    @depthcontrol
    def singleExpression_ObjectLiteralExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ObjectLiteralExpression'))
        current += self.objectLiteral()
        return current
    singleExpression_ObjectLiteralExpression.min_depth = 1

    @depthcontrol
    def singleExpression_ParenthesizedExpression(self):
        current = self.create_node(UnparserRule(name='singleExpression_ParenthesizedExpression'))
        current += self.create_node(UnlexerRule(src='('))
        current += self.expressionSequence()
        current += self.create_node(UnlexerRule(src=')'))
        return current
    singleExpression_ParenthesizedExpression.min_depth = 4

    @depthcontrol
    def assignable(self):
        current = self.create_node(UnparserRule(name='assignable'))
        choice = self.choice([0 if [2, 2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1005', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_1005', choice)] = self.unlexer.weights.get(('alt_1005', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.identifier()
        elif choice == 1:
            current += self.arrayLiteral()
        elif choice == 2:
            current += self.objectLiteral()
        return current
    assignable.min_depth = 1

    @depthcontrol
    def objectLiteral(self):
        current = self.create_node(UnparserRule(name='objectLiteral'))
        current += self.create_node(UnlexerRule(src='{'))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.propertyAssignment()
                if self.unlexer.max_depth >= 4:
                    for _ in self.zero_or_more():
                        current += self.create_node(UnlexerRule(src=','))
                        current += self.propertyAssignment()


        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src=','))

        current += self.create_node(UnlexerRule(src='}'))
        return current
    objectLiteral.min_depth = 0

    @depthcontrol
    def anoymousFunction(self):
        current = self.create_node(UnparserRule(name='anoymousFunction'))
        choice = self.choice([0 if [4, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1016', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_1016', choice)] = self.unlexer.weights.get(('alt_1016', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current = self.anoymousFunction_FunctionDecl()
        elif choice == 1:
            current = self.anoymousFunction_AnoymousFunctionDecl()
        elif choice == 2:
            current = self.anoymousFunction_ArrowFunction()
        return current
    anoymousFunction.min_depth = 2

    @depthcontrol
    def anoymousFunction_FunctionDecl(self):
        current = self.create_node(UnparserRule(name='anoymousFunction_FunctionDecl'))
        current += self.functionDeclaration()
        return current
    anoymousFunction_FunctionDecl.min_depth = 3

    @depthcontrol
    def anoymousFunction_AnoymousFunctionDecl(self):
        current = self.create_node(UnparserRule(name='anoymousFunction_AnoymousFunctionDecl'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Async()

        current += self.unlexer.Function()
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='*'))

        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 4:
            for _ in self.zero_or_one():
                current += self.formalParameterList()

        current += self.create_node(UnlexerRule(src=')'))
        current += self.create_node(UnlexerRule(src='{'))
        current += self.functionBody()
        current += self.create_node(UnlexerRule(src='}'))
        return current
    anoymousFunction_AnoymousFunctionDecl.min_depth = 1

    @depthcontrol
    def anoymousFunction_ArrowFunction(self):
        current = self.create_node(UnparserRule(name='anoymousFunction_ArrowFunction'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_one():
                current += self.unlexer.Async()

        current += self.arrowFunctionParameters()
        current += self.create_node(UnlexerRule(src='=>'))
        current += self.arrowFunctionBody()
        return current
    anoymousFunction_ArrowFunction.min_depth = 2

    @depthcontrol
    def arrowFunctionParameters(self):
        current = self.create_node(UnparserRule(name='arrowFunctionParameters'))
        choice = self.choice([0 if [2, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1030', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_1030', choice)] = self.unlexer.weights.get(('alt_1030', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.identifier()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='('))
            if self.unlexer.max_depth >= 4:
                for _ in self.zero_or_one():
                    current += self.formalParameterList()

            current += self.create_node(UnlexerRule(src=')'))
        return current
    arrowFunctionParameters.min_depth = 0

    @depthcontrol
    def arrowFunctionBody(self):
        current = self.create_node(UnparserRule(name='arrowFunctionBody'))
        choice = self.choice([0 if [3, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1036', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_1036', choice)] = self.unlexer.weights.get(('alt_1036', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.singleExpression()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='{'))
            current += self.functionBody()
            current += self.create_node(UnlexerRule(src='}'))
        return current
    arrowFunctionBody.min_depth = 1

    @depthcontrol
    def assignmentOperator(self):
        current = self.create_node(UnparserRule(name='assignmentOperator'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1041', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_1041', choice)] = self.unlexer.weights.get(('alt_1041', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='*='))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='/='))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='%='))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='+='))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='-='))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='<<='))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src='>>='))
        elif choice == 7:
            current += self.create_node(UnlexerRule(src='>>>='))
        elif choice == 8:
            current += self.create_node(UnlexerRule(src='&='))
        elif choice == 9:
            current += self.create_node(UnlexerRule(src='^='))
        elif choice == 10:
            current += self.create_node(UnlexerRule(src='|='))
        elif choice == 11:
            current += self.create_node(UnlexerRule(src='**='))
        return current
    assignmentOperator.min_depth = 0

    @depthcontrol
    def literal(self):
        current = self.create_node(UnparserRule(name='literal'))
        choice = self.choice([0 if [1, 1, 1, 1, 2, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1066', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_1066', choice)] = self.unlexer.weights.get(('alt_1066', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NullLiteral()
        elif choice == 1:
            current += self.unlexer.BooleanLiteral()
        elif choice == 2:
            current += self.unlexer.StringLiteral()
        elif choice == 3:
            current += self.unlexer.TemplateStringLiteral()
        elif choice == 4:
            current += self.unlexer.RegularExpressionLiteral()
        elif choice == 5:
            current += self.numericLiteral()
        elif choice == 6:
            current += self.bigintLiteral()
        return current
    literal.min_depth = 1

    @depthcontrol
    def numericLiteral(self):
        current = self.create_node(UnparserRule(name='numericLiteral'))
        choice = self.choice([0 if [1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1074', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_1074', choice)] = self.unlexer.weights.get(('alt_1074', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.DecimalLiteral()
        elif choice == 1:
            current += self.unlexer.HexIntegerLiteral()
        elif choice == 2:
            current += self.unlexer.OctalIntegerLiteral()
        elif choice == 3:
            current += self.unlexer.OctalIntegerLiteral2()
        elif choice == 4:
            current += self.unlexer.BinaryIntegerLiteral()
        return current
    numericLiteral.min_depth = 1

    @depthcontrol
    def bigintLiteral(self):
        current = self.create_node(UnparserRule(name='bigintLiteral'))
        choice = self.choice([0 if [2, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1080', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_1080', choice)] = self.unlexer.weights.get(('alt_1080', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.BigDecimalIntegerLiteral()
        elif choice == 1:
            current += self.unlexer.BigHexIntegerLiteral()
        elif choice == 2:
            current += self.unlexer.BigOctalIntegerLiteral()
        elif choice == 3:
            current += self.unlexer.BigBinaryIntegerLiteral()
        return current
    bigintLiteral.min_depth = 1

    @depthcontrol
    def getter(self):
        current = self.create_node(UnparserRule(name='getter'))
        current += self.identifier()
        current += self.propertyName()
        return current
    getter.min_depth = 2

    @depthcontrol
    def setter(self):
        current = self.create_node(UnparserRule(name='setter'))
        current += self.identifier()
        current += self.propertyName()
        return current
    setter.min_depth = 2

    @depthcontrol
    def identifierName(self):
        current = self.create_node(UnparserRule(name='identifierName'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1085', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_1085', choice)] = self.unlexer.weights.get(('alt_1085', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.identifier()
        elif choice == 1:
            current += self.reservedWord()
        return current
    identifierName.min_depth = 2

    @depthcontrol
    def identifier(self):
        current = self.create_node(UnparserRule(name='identifier'))
        choice = self.choice([0 if [2, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1088', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_1088', choice)] = self.unlexer.weights.get(('alt_1088', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Identifier()
        elif choice == 1:
            current += self.unlexer.NonStrictLet()
        elif choice == 2:
            current += self.unlexer.Async()
        return current
    identifier.min_depth = 1

    @depthcontrol
    def reservedWord(self):
        current = self.create_node(UnparserRule(name='reservedWord'))
        choice = self.choice([0 if [2, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1092', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_1092', choice)] = self.unlexer.weights.get(('alt_1092', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.keyword()
        elif choice == 1:
            current += self.unlexer.NullLiteral()
        elif choice == 2:
            current += self.unlexer.BooleanLiteral()
        return current
    reservedWord.min_depth = 1

    @depthcontrol
    def keyword(self):
        current = self.create_node(UnparserRule(name='keyword'))
        choice = self.choice([0 if [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1096', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_1096', choice)] = self.unlexer.weights.get(('alt_1096', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Break()
        elif choice == 1:
            current += self.unlexer.Do()
        elif choice == 2:
            current += self.unlexer.Instanceof()
        elif choice == 3:
            current += self.unlexer.Typeof()
        elif choice == 4:
            current += self.unlexer.Case()
        elif choice == 5:
            current += self.unlexer.Else()
        elif choice == 6:
            current += self.unlexer.New()
        elif choice == 7:
            current += self.unlexer.Var()
        elif choice == 8:
            current += self.unlexer.Catch()
        elif choice == 9:
            current += self.unlexer.Finally()
        elif choice == 10:
            current += self.unlexer.Return()
        elif choice == 11:
            current += self.unlexer.Void()
        elif choice == 12:
            current += self.unlexer.Continue()
        elif choice == 13:
            current += self.unlexer.For()
        elif choice == 14:
            current += self.unlexer.Switch()
        elif choice == 15:
            current += self.unlexer.While()
        elif choice == 16:
            current += self.unlexer.Debugger()
        elif choice == 17:
            current += self.unlexer.Function()
        elif choice == 18:
            current += self.unlexer.This()
        elif choice == 19:
            current += self.unlexer.With()
        elif choice == 20:
            current += self.unlexer.Default()
        elif choice == 21:
            current += self.unlexer.If()
        elif choice == 22:
            current += self.unlexer.Throw()
        elif choice == 23:
            current += self.unlexer.Delete()
        elif choice == 24:
            current += self.unlexer.In()
        elif choice == 25:
            current += self.unlexer.Try()
        elif choice == 26:
            current += self.unlexer.Class()
        elif choice == 27:
            current += self.unlexer.Enum()
        elif choice == 28:
            current += self.unlexer.Extends()
        elif choice == 29:
            current += self.unlexer.Super()
        elif choice == 30:
            current += self.unlexer.Const()
        elif choice == 31:
            current += self.unlexer.Export()
        elif choice == 32:
            current += self.unlexer.Import()
        elif choice == 33:
            current += self.unlexer.Implements()
        elif choice == 34:
            current += self.let_()
        elif choice == 35:
            current += self.unlexer.Private()
        elif choice == 36:
            current += self.unlexer.Public()
        elif choice == 37:
            current += self.unlexer.Interface()
        elif choice == 38:
            current += self.unlexer.Package()
        elif choice == 39:
            current += self.unlexer.Protected()
        elif choice == 40:
            current += self.unlexer.Static()
        elif choice == 41:
            current += self.unlexer.Yield()
        elif choice == 42:
            current += self.unlexer.Async()
        elif choice == 43:
            current += self.unlexer.Await()
        elif choice == 44:
            current += self.unlexer.From()
        elif choice == 45:
            current += self.unlexer.As()
        return current
    keyword.min_depth = 1

    @depthcontrol
    def let_(self):
        current = self.create_node(UnparserRule(name='let_'))
        choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1143', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_1143', choice)] = self.unlexer.weights.get(('alt_1143', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NonStrictLet()
        elif choice == 1:
            current += self.unlexer.StrictLet()
        return current
    let_.min_depth = 1

    @depthcontrol
    def eos(self):
        current = self.create_node(UnparserRule(name='eos'))
        choice = self.choice([0 if [1, 1, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_1146', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_1146', choice)] = self.unlexer.weights.get(('alt_1146', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.SemiColon()
        elif choice == 1:
            current += self.unlexer.EOF()
        elif choice == 2:
            pass
        elif choice == 3:
            pass
        return current
    eos.min_depth = 0

    default_rule = program

